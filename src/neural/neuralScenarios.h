#ifndef NEURAL_SCENARIOS_H
#define NEURAL_SCENARIOS_H

#include <memory>
#include <chrono>
#include <cmath>
#include <utility>
#include "scenario.h"
#include "neuralEconomy.h"
#include "utilMaxer.h"
#include "profitMaxer.h"
#include "advantageActorCritic.h"
#include "util.h"
#include "constants.h"
#include "neuralConstants.h"


namespace neural {

// a NeuralScenario returns a neuralEconomy rather than a base Economy
class NeuralScenario : public Scenario {
public:
    NeuralScenario();
    NeuralScenario(
        std::shared_ptr<AdvantageActorCritic> trainer
    );

    std::shared_ptr<DecisionNetHandler> handler;
    std::shared_ptr<AdvantageActorCritic> trainer;

    std::shared_ptr<NeuralEconomy> get_economy(
        std::vector<std::string> goods
    );
};


class SimpleScenario : public NeuralScenario {
    // A basic scenario with two persons and one firm, helpful for testing/debugging
public:
    SimpleScenario();
    SimpleScenario(
        std::shared_ptr<AdvantageActorCritic> trainer
    );

    virtual std::shared_ptr<Economy> setup();
};


struct CustomScenarioParams {

    CustomScenarioParams(
        unsigned int numPeople,
        unsigned int numFirms
    ) : numPeople(numPeople), numFirms(numFirms) {}

    unsigned int numPeople;
    unsigned int numFirms;

    // params for people

    double money_mu = 10.0;
    double money_sigma = 2.0;
    double good1_mu = 10.0;
    double good1_sigma = 2.0;
    double good2_mu = 1.0;
    double good2_sigma = 0.2;

    // it's okay if these don't sum to 1 as they will be normalized
    double labor_share_mu = 0.4;
    double labor_share_sigma = 0.1;
    double good1_share_mu = 0.4;
    double good1_share_sigma = 0.1;
    double good2_share_mu = 0.1;
    double good2_share_sigma = 0.02;

    // will be plugged into logistic function
    double discount_mu = 2.0;
    double discount_sigma = 1.0;

    double elasticity_mu = 10.0;
    double elasticity_sigma = 2.5;

    // params for firms

    double firm_money_mu = 50.0;
    double firm_money_sigma = 10.0;
    double firm_good1_mu = 10.0;
    double firm_good1_sigma = 4.0;
    double firm_good2_mu = 30.0;
    double firm_good2_sigma = 5.0;

    double firm_tfp1_mu = 1.0;
    double firm_tfp1_sigma = 0.2;
    double firm_tfp2_mu = 1.0;
    double firm_tfp2_sigma = 0.2;

    double firm_labor_share1_mu = 0.4;
    double firm_labor_share1_sigma = 0.05;
    double firm_good1_share1_mu = 0.1;
    double firm_good1_share1_sigma = 0.02;
    double firm_good2_share1_mu = 0.4;
    double firm_good2_share1_sigma = 0.02;

    double firm_labor_share2_mu = 0.4;
    double firm_labor_share2_sigma = 0.05;
    double firm_good1_share2_mu = 0.1;
    double firm_good1_share2_sigma = 0.02;
    double firm_good2_share2_mu = 0.4;
    double firm_good2_share2_sigma = 0.05;

    double firm_elasticity1_mu = 10.0;
    double firm_elasticity1_sigma = 2.5;
    double firm_elasticity2_mu = 10.0;
    double firm_elasticity2_sigma = 2.5;
};


class CustomScenario : public NeuralScenario {
    // A versatile scenario: create a struct of parameters just how you like it or use the default config ;)
public:
    CustomScenario(
        unsigned int numPeople,
        unsigned int numFirms
    );
    
    CustomScenario(
        std::shared_ptr<AdvantageActorCritic> trainer,
        unsigned int numPeople,
        unsigned int numFirms
    );
    
    CustomScenario(
        std::shared_ptr<AdvantageActorCritic> trainer,
        CustomScenarioParams params
    );

    virtual std::shared_ptr<Economy> setup();

    // can be used to get a placeholder for the sort of economy generated by setup()
    // without actually having instantiated an instance of this struct
    static std::shared_ptr<NeuralEconomy> setup_dummy();

    CustomScenarioParams params;
};



struct TrainingParams {
    TrainingParams(
        unsigned int numEpisodes,
        unsigned int episodeLength,
        unsigned int updateEveryNEpisodes,
        unsigned int checkpointEveryNEpisodes
    ) : numEpisodes(numEpisodes),
        episodeLength(episodeLength),
        updateEveryNEpisodes(updateEveryNEpisodes),
        checkpointEveryNEpisodes(checkpointEveryNEpisodes)
    {}

    TrainingParams() {}

    unsigned int numEpisodes = DEFAULT_NUM_EPISODES;
    unsigned int episodeLength = DEFAULT_EPISODE_LENGTH;
    unsigned int updateEveryNEpisodes = DEFAULT_UPDATE_EVERY_N_EPISODES;
    unsigned int checkpointEveryNEpisodes = DEFAULT_CHECKPOINT_EVERY_N_EPISODES;

    unsigned int stackSize = DEFAULT_STACK_SIZE;
    unsigned int encodingSize = DEFAULT_ENCODING_SIZE;
    unsigned int hiddenSize = DEFAULT_HIDDEN_SIZE;
    unsigned int nHidden = DEFAULT_N_HIDDEN;
    unsigned int nHiddenSmall = DEFAULT_N_HIDDEN_SMALL;

    double purchaseNetLR = DEFAULT_LEARNING_RATE;
    double firmPurchaseNetLR = DEFAULT_LEARNING_RATE;
    double laborSearchNetLR = DEFAULT_LEARNING_RATE;
    double consumptionNetLR = DEFAULT_LEARNING_RATE;
    double productionNetLR = DEFAULT_LEARNING_RATE;
    double offerNetLR = DEFAULT_LEARNING_RATE;
    double jobOfferNetLR = DEFAULT_LEARNING_RATE;
    double valueNetLR = DEFAULT_LEARNING_RATE;
    double firmValueNetLR = DEFAULT_LEARNING_RATE;
    unsigned int episodeBatchSizeForLRDecay = DEFAULT_EPISODE_BATCH_SIZE_FOR_LR_DECAY;
    unsigned int patienceForLRDecay = DEFAULT_PATIENCE_FOR_LR_DECAY;
    double multiplierForLRDecay = DEFAULT_MULTIPLIER_FOR_LR_DECAY;
    unsigned int reverseAnnealingPeriod = DEFAULT_REVERSE_ANNEALING_PERIOD;
};


std::shared_ptr<CustomScenario> create_scenario(
    const CustomScenarioParams& scenarioParams,
    const TrainingParams& trainingParams
);

std::vector<double> train(
    const std::shared_ptr<NeuralScenario>& scenario,
    TrainingParams& params
);

// this is just a convenience function if you don't want to create a TrainingParams object
std::vector<double> train(
    const std::shared_ptr<NeuralScenario>& scenario,
    unsigned int numEpisodes,
    unsigned int episodeLength,
    unsigned int updateEveryNEpisodes,
    unsigned int checkpointEveryNEpisodes
);

// This is the easiest way to set up training in most cases
// Just supply a CustomScenarioParams struct and a TrainingParams struct
std::vector<double> train(
    const CustomScenarioParams& scenarioParams,
    TrainingParams& trainingParams
);

// Same as above but loads the neural net params from disk if some training has already been done
std::vector<double> train_from_pretrained(
    const CustomScenarioParams& scenarioParams,
    TrainingParams& trainingParams,
    // perturbationSize is in [0, 1].
    // if perturbationSize > 0, then noise will be added to all the model parameters
    double perturbationSize = 0.0
);


} // namespace neural



#endif